#!/usr/bin/perl

use strict;
use warnings;
use Getopt::Long;
#use Smart::Comments;

#-----------------------------------------------------------------------------
#----------------------------------- MAIN ------------------------------------
#-----------------------------------------------------------------------------

my $usage = << 'END_USAGE';

gff_treeview [OPTIONS] <gff_file> [<gff_file> ...]

This script takes a gff file(s) and builds a relationship tree for it, counts
the members of each type, and prints a nice report.  The report is split and 
sorted by source (column 1 in the gff file), and any relationships between 
types are represented by an ASCII tree.  Counts for each type are printed 
as well.

OPTIONS
    --format  Print the output in:
                tree  => tree format (default)
                table => tabluar format

END_USAGE

my $format = 'tree';
my $success = GetOptions('format=s'  => \$format);
die $usage if ! defined $success;

my $files = \@ARGV;
die $usage if scalar @{$files} < 1;

my $features = parse_files($files);
my $group_map = map_groups($features);
remap_groups($group_map, $features);
my $id_type_map = map_id_type($features);
my $parent_type_map = map_parent_type($features, $id_type_map);
my $tree = build_tree($features, $parent_type_map);

#Print header, path and file info first
print "#" x 80 . "\n";
print " " x 33 . "GFF Tree View\n";
print "#" x 80, "\n";
print "Path: " . `pwd`;
print "Files:\n";
print join "\n", @{$files};
print "\n";
print "#" x 80, "\n";
	
if ($format eq 'table') {
	print_table($tree);
}
else {
	print_tree($tree);
}
print "Done\n\n";
#-----------------------------------------------------------------------------
#------------------------------- SUBROUTINES ---------------------------------
#-----------------------------------------------------------------------------
sub parse_files {
	my $files = shift;
	my %features;
	for my $file (@{$files}) {
		
		open (my $IN, '<', $file) 
		    or die "Can't open $file for reading\n";
		
		#Parse each line of GFF
		while (<$IN>) { ### Pasrsing $file|===[%]    |
			
			last if /^\#\#FASTA/; #Skip sequence lines at the end.
			next if /^[\#\s]/; #Skip comment lines.
			chomp;
			
			my $feature = parse_gff_line($_);
			next if ! defined $feature;
			push @{$features{$feature->{Source}}}, $feature;
		}
	}
	return \%features;
}
#-----------------------------------------------------------------------------
sub parse_gff_line {
	my $line = shift;

	#Split the line.
	my ($seq_id, $source, $type, $start, $end, $score, 
	    $strand, $phase, $attribute_field) 
	    = split /\t/, $line;

	return undef unless this_type_is_wanted($type);
	
	#Skip lines that have needed feilds undef or eq '.'
	return if grep {! defined $_} ($seq_id, $source, 
				       $type, $attribute_field);
	return if grep {$_ eq '.'}    ($seq_id, $type, $attribute_field);
	
	#Process the attributes field.
	my $attributes = parse_attributes($attribute_field);
	
	my $feature = {SeqID    => $seq_id,
		       Source   => $source,
		       Type     => $type,
		       #Don't need these feilds for this script.
		       #Start    => $start,
		       #End      => $end,
		       #Score    => $score,
		       #Strand   => $strand,
		       #Phase    => $phase,
		       Attribute => $attributes};

	return $feature;
}
#-----------------------------------------------------------------------------
sub this_type_is_wanted {
	my $type = shift;
	
	my @wanted_types = qw(gene mRNA CDS);

	if (grep {$type eq $_} @wanted_types) {
		return 1;
	}
	return undef;
}
#-----------------------------------------------------------------------------
sub parse_attributes {
        my $attribute_field = shift;
        my ($id, $parent, $group);

        my $id_regex     = qr/ID\s+(\S+)/;
        my $parent_regex = qr/FlyBase:(\S+)/;
	my $group_regex  = qr/group\s+(\S+)/;

        ($id)     = $attribute_field =~ $id_regex;
        ($parent) = $attribute_field =~ $parent_regex;
        ($group)  = $attribute_field =~ $group_regex;

	$id     =~ s/[\"\s]//g if $id;
	$parent =~ s/[\"\s]//g if $parent;
	$group  =~ s/[\"\s]//g if $group;

        my $parents = [];
	if ($parent) {
		@{$parents} = split /,/, $parent;
	}
        my $attributes = {ID     => [$id],
                          Parent => $parents,
			  Group  => [$group]};
		
        return $attributes;
}
#-----------------------------------------------------------------------------
sub map_groups {
	my $features = shift;
	my %group_map;
	for my $source (keys %{$features}) {
		#Loop over all features.
		for my $feature (@{$features->{$source}}) {
			my $group  = $feature->{Attribute}{Group}[0];
			my $id     = $feature->{Attribute}{ID}[0];
			my $parent = $feature->{Attribute}{Parent}[0];
			next if ! defined $group;
			#Fill the %group_map hash as a 
			#lookup index for later.
			if ($id || $parent) {
				$group_map{$group}{ID}     ||= [$id];
				$group_map{$group}{Parent} ||= [$parent];
			}
		}
	}
	return \%group_map;
}
#-----------------------------------------------------------------------------
sub remap_groups {
	my ($group_map, $features) = @_;
	for my $source (keys %{$features}) {
		#Loop over all features.
		for my $feature (@{$features->{$source}}) {
			my $group  = $feature->{Attribute}{Group}[0];
			my $id     = $feature->{Attribute}{ID}[0];
			my $parent = $feature->{Attribute}{Parent}[0];
			next if ! defined $group;
			$feature->{Attribute}{ID}[0]     ||= 
			    $group_map->{$group}{ID}[0];
			$feature->{Attribute}{Parent}[0] ||=
			    $group_map->{$group}{Parent}[0];
			print '';
		}
	}
}
#-----------------------------------------------------------------------------
sub map_id_type {
	my $features = shift;
	my %id_type_map;
	for my $source (keys %{$features}) { ### Mapping===[%]     done
		#Loop over all features.
		for my $feature (@{$features->{$source}}) {
			#Fill the %id_type_map hash as a 
			#lookup index for loop below.
			if ($feature->{Attribute}{ID}[0]) {
				my $first_and_only_ID = 
				    $feature->{Attribute}{ID}[0];
				$id_type_map{$first_and_only_ID} = 
				    $feature->{Type};
			}
		}
	}
	return \%id_type_map;
}
#-----------------------------------------------------------------------------
#Map parent type for every type that has a parent so we can lookup parent 
#type by my type.
sub map_parent_type {
	my ($features, $id_type_map) = @_;
	my %parent_type_map;
	for my $source (keys %{$features}) { ### Mapping===[%]     done
		#Loop over all features.
		for my $feature (@{$features->{$source}}) {
			#Get parent type...
			my $parent_type = get_parent_type($feature,
							  $id_type_map);
			next if ! defined $parent_type;
			#...and map it to the hash (i.e. my source, my 
			#type => my parent's type.
			$parent_type_map{$source}{$feature->{Type}} 
			= $parent_type;
		}
	}
	return \%parent_type_map;
}
#-----------------------------------------------------------------------------
sub get_parent_type {
	my ($feature, $id_type_map) = @_;
	#If this feature actually has a parent...
	if ($feature->{Attribute}{Parent}[0]) {
		#...return it's type...
		return $id_type_map->{$feature->{Attribute}{Parent}[0]}
	}
	return undef;
}
#-----------------------------------------------------------------------------
sub build_tree {
	my ($features, $parent_type_map) = @_;
	my %tree;
	#Loop over all features and map their geneology to a family tree
	for my $source (keys %{$features}) { 
		### Building Trees===[%]     done
		for my $feature (@{$features->{$source}}) {
			#Get the current type and initialize a type 
			#storage container.
			my $type_storage = $feature->{Type};
			my $current_type = $feature->{Type};
			my $parent_type;
			#Recursively look up parent type until we reach the 
			#base, and add each parent type to a growing string 
			#which holds the geneology of this type. 
			#(i.e. gene::mRNA::exon).
			while ($parent_type  =
			       $parent_type_map->{$source}{$current_type}) {
				#Some gff files have features that are their 
				#own parents.  Run away! Infinte loop!
				last if 
				    $parent_type eq $current_type;
				#If the current type has a parent - add it to
				#the geneology else end.
				if ($parent_type) {
					#Add to geneology
					$type_storage = $parent_type . 
					    "::$type_storage";
					#Reset current type for next recurse.
					$current_type = $parent_type;
				}
				else {
					$current_type = undef;
				}
			}
			#Tidy up the geneology...
			$type_storage =~ s/::$//;
			#And hash it for uniqueness.
			$tree{$source}{$type_storage} ++;
		}
	}
	return \%tree;
}
#-----------------------------------------------------------------------------
sub print_tree {
	my $tree = shift;

	#For every feature type print it...
	for my $source (sort keys %{$tree}) {
		print "$source (";
		#Print the source and it's members
		print scalar (keys %{$tree->{$source}}) . "):\n";
		print "-" x 80 . "\n";
		#For each leaf in the geneology
		for my $tree_leaf (sort keys %{$tree->{$source}}) {
			#Split the nodes...
			my @nodes = split /::/, $tree_leaf;
			#...pick the leaf...
			my $leaf = pop @nodes;
			#...space the branches...
			for (1 .. scalar @nodes - 1) {
				print "\t";
			}
			#...print the branches and leaf...
			print "  |_____" if scalar @nodes >= 1;
			print "$leaf (";
			#...and print the count of that leaf type.
			print $tree->{$source}{$tree_leaf} . "):\n";
		}
		print "\n\n";
	}
}
#-----------------------------------------------------------------------------
sub print_table {
	my $tree = shift;

	#For every feature type print it...
	for my $source (sort keys %{$tree}) {
		#For each leaf in the geneology
		for my $leaf (sort keys %{$tree->{$source}}) {
			print "${source}::${leaf}\t";
			#...and print the count of that leaf type.
			print $tree->{$source}{$leaf} . "\n";
		}
	}
}
#-----------------------------------------------------------------------------

