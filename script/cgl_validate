#!/usr/bin/perl -w

eval 'exec /usr/bin/perl -w  -S $0 ${1+"$@"}'
    if 0; # not running under some shell

use strict;

BEGIN {
	$ENV{'CGL_CHATTER'} = 0;
}


$| = 1;
use FileHandle;
use CGL::Annotation;
use CGL::Annotation::Iterator;
use CGL::TranslationMachine;
use CGL::Ontology::SO;

my $usage = "

cgl_validate: a simple script that attempts to check 
          the semantic integrity of a chaos.xml 
          document 

cgl_validate <chaos.xml file>

cgl_validate CG33070.chaos.xml


\n"; 

#-----------------------------------------------------------------------------
#----------------------------------- MAIN ------------------------------------
#-----------------------------------------------------------------------------

die $usage unless $ARGV[0];

my $file  = $ARGV[0];


my $SO = new CGL::Ontology::SO();

my $TM = new CGL::TranslationMachine();

my $chaos = new CGL::Annotation($file);

my $focus = $chaos->meta_data('focus_feature_id')
    || 'no focus given in file';


my $i = 0;
while (my $c = $chaos->contig($i)){
	epitaph()  unless defined($c->residues); #gh exit(1) ?
	$i++;
}
my $iterator = new CGL::Annotation::Iterator($chaos);


### Merge this with the loop below ###
while (my $gene = $iterator->next_by_gene()) {
	next unless $gene->id eq $focus;
	if (! defined $gene->transcript(0)) {
		my $lt = $gene->properties('locus_tag')
		    if $gene->properties('locus_tag');
		my $syns = find_synonyms($gene) || 
		    'no_synonyms_for_this_gene';
		print "NO_TRNSCPT\t" . $gene->uniquename(). 
		    ":$lt\t$syns\t$file\n"; 
	}
}

my %seen;
while (my $data = $iterator->next_by_transcript()){
                my $t = $data->[0];
                my $g = $data->[1];

		epitaph() unless has_transcript_if_required($g); #gh: exit(2) ?

		epitaph() unless has_protein_if_required($t);    #gh: exit(3) ?

		next unless transcript_is_in_scope($t); 

		
		epitaph() unless provided_transcript_residues_match_computed($t); #gh: exit(4) ?

		my $i = 0;
		while (my $p  = $t->translation($i)){
			epitaph() unless provided_translation_residues_match_computed($t, $p); #gh:exit(5) ?
			$i++;
		}
		$seen{$g->id} = $g;
}



foreach my $id (keys %seen){
	if (defined($focus)) {next unless $id eq $focus};

	my $g = $seen{$id};
	my $lt = $g->properties('locus_tag')
	    if $g->properties('locus_tag');
	my $syns = find_synonyms($g) || 'no_synonyms_for_this_gene';
	print "DOC_VALID\t" . $g->uniquename(). ":$lt\t$syns\t$file\n"; 
}

exit(0);
#-----------------------------------------------------------------------------
#---------------------------------- SUBS -------------------------------------
#-----------------------------------------------------------------------------
sub epitaph {

	die "DOC_INVALID"."\t"."-"."\t"."-"."\t".$file."\n";
}
#-----------------------------------------------------------------------------
sub provided_translation_residues_match_computed {
        my $t = shift;
	my $p = shift;

        if (defined($p->residues)){
                my $residues = compute_protein_residues($t, $p);  

		return 0 unless defined($residues);

                return 0 unless $p->residues() eq $residues;
        }
        else {
        }

        return 1;
}
#-----------------------------------------------------------------------------
sub compute_protein_residues {
	my $t = shift;
	my $p = shift;

	my $transcript_residues = compute_transcript_residues($t);
 
	my $translation_offset = $p->metaPos($t, 0);

	my $translation = $TM->translate_from_offset($transcript_residues, $translation_offset);

	($translation) = $translation =~ /([A-Z]+)/;

	return $translation;
}
#-----------------------------------------------------------------------------
sub provided_transcript_residues_match_computed {
	my $t = shift;

	if (defined($t->residues)){
		my $residues = compute_transcript_residues($t); 

		return 0 unless defined($residues);

		return 0 unless $t->residues() eq $residues;
	}
	else {
	}

	return 1;
}
#-----------------------------------------------------------------------------
sub transcript_is_in_scope {
	my $t = shift;

	foreach my $e (@{$t->exons}){
		return 0 unless $e->inScope();
	}

	return 1;
}
#-----------------------------------------------------------------------------
sub compute_transcript_residues {
	my $t = shift;

        my $nB = $t->nbeg();
        my $nE = $t->nend();

        my $residues  ='';
        foreach my $e (@{$t->exons}){
                unless (defined($e->residues)){
                        return undef;
                }
                $residues .= $e->residues();
        }

	return $residues;

}
#-----------------------------------------------------------------------------
sub has_transcript_if_required {
        my $g = shift;


        if ($SO->a_is_hyponym_of_b($g->type(), 'gene')){
                return 0 unless defined($g->transcript(0));
        }
        else {
        }

        return 1;
}
#-----------------------------------------------------------------------------
sub has_protein_if_required {
	my $t = shift;

	
	if ($SO->a_is_hyponym_of_b($t->type(), 'mRNA')){
		return 0 unless defined($t->translation(0));
	}
	else {
	}

	return 1;
}
#-----------------------------------------------------------------------------

sub find_synonyms {
    my $g = shift;
    my $note_holder = $g->properties('note');
    my @notes;
    if (ref $note_holder eq 'ARRAY') {
	@notes = @$note_holder;
    }
    else {
	@notes = ();
    }
    my $olt = $g->properties('old_locus_tag')
	if $g->properties('old_locus_tag');
    my $lt = $g->properties('locus_tag')
	if $g->properties('locus_tag');
    my %synonyms;
    for my $note (@notes) {
	if ($note =~ s/synonym[s]?:\s*//) {
	    map {$synonyms{$_}++} split /[,;]/, $note;
	}
    }
    $synonyms{$olt}++ if $olt;
    $synonyms{$lt}++ if $lt;
    my $synonym_list = join "; ", sort keys %synonyms;
    return $synonym_list;
}















