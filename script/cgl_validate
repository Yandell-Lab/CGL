#!/usr/bin/perl
use strict;
use warnings;

use FileHandle;
use CGL::Annotation;
use CGL::Annotation::Iterator;
use CGL::TranslationMachine;
use CGL::Ontology::SO;

#-----------------------------------------------------------------------------
#----------------------------------- MAIN ------------------------------------
#-----------------------------------------------------------------------------
my $usage = "

A script that checks the semantic integrity of a chaos.xml document. 

cgl_validate <chaos.xml>

"; 

my $file  = shift;
die $usage unless $file;

my $SO = new CGL::Ontology::SO();
my $TM = new CGL::TranslationMachine();

my $chaos;
eval {$chaos= new CGL::Annotation($file)};
print_out('DOC_INVALID', undef, $file) if $@;

my $focus = $chaos->meta_data('focus_feature_id')
    || 'no focus given in file';

my $i = 0;
while (my $c = $chaos->contig($i++)){
	print_out('DOC_INVALID', undef, $file)  
	    unless defined($c->residues);
}

my $iterator = new CGL::Annotation::Iterator($chaos);

while (my $g = $iterator->next_by_gene()) {
	next unless $g->id eq $focus;
	
	unless (has_transcript_if_required($g)) {
		print_out('NO_TRANSCRIPT', $g, $file);
		next;
	}
	
	my $i = 0;
	while (my $t = $g->transcript($i++)) {		
		next unless transcript_is_in_scope($t); 
		print_out('DOC_INVALID', $g, $file)
		    unless has_protein_if_required($t);
		print_out('DOC_INVALID', $g, $file)
		    unless transcript_resd_match_computed($t);
		
		my $i = 0;
		while (my $p  = $t->translation($i++)){
			print_out('DOC_INVALID', $g, $file) 
			    unless translation_resd_match_computed($t, $p);
		}
	}
	print_out('DOC_VALID', $g, $file);
}

exit(0);
#-----------------------------------------------------------------------------
#---------------------------------- SUBS -------------------------------------
#-----------------------------------------------------------------------------
sub print_out {
	my ($label, $g, $file) = @_;

	my $name      = 'no_name';
	my $locus_tag = 'no_locus_tag';
	my $synonyms  = 'no_synonyms';

	if ($g) {
		$locus_tag = get_locus_tag($g) || 'no_locus_tag';
		$synonyms  = find_synonyms($g) || 'no_synonyms_for_this_gene';
		$name      = $g->uniquename()  || 'no_unique_name';
	}

	print "$label\t$name:$locus_tag\t$synonyms\t$file\n";
	die if $label =~ /DOC_INVALID/;
}
#-----------------------------------------------------------------------------
sub translation_resd_match_computed {
        my $t = shift;
	my $p = shift;

        if (defined($p->residues)){
                my $residues = compute_protein_residues($t, $p);  
		return 0 unless defined($residues);
                return 0 unless $p->residues() eq $residues;
        }

        return 1;
}
#-----------------------------------------------------------------------------
sub compute_protein_residues {
	my $t = shift;
	my $p = shift;

	my $transcript_residues = compute_transcript_residues($t);
	my $translation_offset = $p->metaPos($t, 0);
	my $translation = $TM->translate_from_offset($transcript_residues, 
						     $translation_offset);

	($translation) = $translation =~ /([A-Z]+)/;

	return $translation;
}
#-----------------------------------------------------------------------------
sub transcript_resd_match_computed {
	my $t = shift;

	if (defined($t->residues)){
		my $residues = compute_transcript_residues($t); 
		return 0 unless defined($residues);
		return 0 unless $t->residues() eq $residues;
	}

	return 1;
}
#-----------------------------------------------------------------------------
sub transcript_is_in_scope {
	my $t = shift;

	foreach my $e (@{$t->exons}){
		return 0 unless $e->inScope();
	}

	return 1;
}
#-----------------------------------------------------------------------------
sub compute_transcript_residues {
	my $t = shift;

        my $nB = $t->nbeg();
        my $nE = $t->nend();

        my $residues  ='';
        foreach my $e (@{$t->exons}){
                unless (defined($e->residues)){
                        return undef;
                }
                $residues .= $e->residues();
        }

	return $residues;

}
#-----------------------------------------------------------------------------
sub has_transcript_if_required {
        my $g = shift;

        if ($SO->a_is_hyponym_of_b($g->type(), 'gene')){
                return 0 unless defined($g->transcript(0));
        }

        return 1;
}
#-----------------------------------------------------------------------------
sub has_protein_if_required {
	my $t = shift;

	if ($SO->a_is_hyponym_of_b($t->type(), 'mRNA')){
		return 0 unless defined($t->translation(0));
	}

	return 1;
}
#-----------------------------------------------------------------------------
sub find_synonyms {
    my $g = shift;
    my $note_holder = $g->properties('note');
    my @notes;
    if (ref $note_holder eq 'ARRAY') {
	@notes = @$note_holder;
    }
    else {
	@notes = ();
    }
    my $olt = $g->properties('old_locus_tag')
	if $g->properties('old_locus_tag');
    my $lt = $g->properties('locus_tag')
	if $g->properties('locus_tag');
    my %synonyms;
    for my $note (@notes) {
	if ($note =~ s/synonym[s]?:\s*//) {
	    map {$synonyms{$_}++} split /[,;]/, $note;
	}
    }
    $synonyms{$olt}++ if $olt;
    $synonyms{$lt}++ if $lt;
    my $synonym_list = join "; ", sort keys %synonyms;
    return $synonym_list;
}
#-----------------------------------------------------------------------------
sub get_locus_tag {
	my $g = shift;
	return $g->properties('locus_tag');
}












